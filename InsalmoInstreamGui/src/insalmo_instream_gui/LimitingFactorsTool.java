/*
 * InSALMO/InSTREAM Graphic User Interface, last revised October 2011.
 * Developed and maintained by Steve Railsback, Lang, Railsback & Associates,
 * Steve@LangRailsback.com and Colin Sheppard, critter@stanfordalumni.org.
 * Development sponsored by US Bureau of Reclamation under the
 * Central Valley Project Improvement Act, EPRI, USEPA, USFWS,
 * USDA Forest Service, and others.
 * Copyright (C) 2011 Lang, Railsback & Associates.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program (see file LICENSE); if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 * */
package insalmo_instream_gui;

import java.awt.Component;
import java.awt.Container;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Hashtable;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import javax.swing.BorderFactory;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.text.DefaultCaret;

public class LimitingFactorsTool {
	private InsalmoInstreamView parent;	
	public static String newline = System.getProperty("line.separator");
	public Boolean terminatedForcefully = false;
	public Boolean isInsalmo;
	
	public enum LFTExperiment{
		WINTER_WATER_TEMP,SUMMER_WATER_TEMP,BASE_FLOW,SPAWNING_GRAVEL_AVAIL,VELOCITY_SHELTER_AVAIL,HIDING_COVER_AVAIL,
		PISCIVORY_RISK,FOOD_AVAIL,REDD_SCOURING,NUM_SPAWNERS
	}
	public LimitingFactorsTool(InsalmoInstreamView parent) {
		this.parent = parent;
		isInsalmo = MetaProject.getInstance().isInsalmo();
	}
	public Boolean setupLFT() throws RuntimeException,IOException, ParseException {
		Project project = parent.getOpenProject();
		String projectDir = parent.getProjectDir().getAbsolutePath();
		SetupParameters lftSetup = project.getSetupParameters("lftSetup-");
		Hashtable<String,ArrayList<String>> uncertaintyData = new Hashtable<String,ArrayList<String>>();

		if(parent.actionHandler.saveProject()){
			if(project.getNumErrors()>0){
				throw new RuntimeException("The project has errors, please fix them before running the Limiting Factors Tool");
			}else if(project.getNumWarnings()>0){
				int response = JOptionPane.showConfirmDialog(parent.parentFrame, "<html><body><b>Are you sure?</b><br><br>" +
						"Warnings exist in the project.  Due to the complexity of the experiments generated by this tool, <br>" +
						"running with warnings could result in unanticipated bugs or a crash of the model.<br><br>Continue anyway?" +
						"</html></body>","Confirm Limitin Factors Tool Run",JOptionPane.YES_OPTION);
				if(response!=0)return false;
			}
			// Generate the combinations of experiment parameters necessary to implement the uncertainty analysis
			Integer numScenarios = lftSetup.getParameter("numScenarios").getParameterIntegerValue();
			Integer numUncertScenarios = lftSetup.getParameter("numUncertaintyScenarios").getParameterIntegerValue();
			Integer numUncertParams = lftSetup.getParameter("numUncertaintyParams").getParameterIntegerValue();
			Integer totalUncertRuns = ((Double)Math.pow(numUncertScenarios.doubleValue(),numUncertParams.doubleValue())).intValue();
			if(numUncertParams<0 || numUncertParams>3){
				throw new RuntimeException("The limiting factors parameter 'numUncertaintyParams' must be in the range 0-3. <br>A value of "+numUncertParams+" was set instead.");
			}else if(numUncertScenarios<1){
				throw new RuntimeException("The limiting factors parameter 'numUncertaintyScenarios' must be greater than 0. <br>A value of "+numUncertScenarios+" was set instead.");
			}else if(totalUncertRuns*numScenarios > 500){
				int response = JOptionPane.showConfirmDialog(parent.parentFrame, "<html><body><b>Are you sure?</b><br><br>" +
						"You are about to conduct a limiting factors experiment that will require "+totalUncertRuns*numScenarios+" model" +
						"runs.  Continue anyway?" +
						"</html></body>","Confirm Limiting Factors Tool Run",JOptionPane.YES_OPTION);
				if(response!=0)return false;
			}
			for(Integer paramNum = 1; paramNum <= numUncertParams; paramNum++){
				String paramName = lftSetup.getParameter("uncertaintyParam"+paramNum).getParameterValue();
				Double uncertLow = Double.parseDouble(lftSetup.getParameter("uncertaintyParam"+paramNum+"LowFactor").getParameterValue());
				Double uncertHigh = Double.parseDouble(lftSetup.getParameter("uncertaintyParam"+paramNum+"HighFactor").getParameterValue());
				Boolean isInt = true;
				if(!MetaProject.getInstance().parameterExists(paramName)){
					throw new RuntimeException("Illegal parameter '"+paramName+"' specified for uncertainty param "+paramNum+".<br>"+
					"No such parameter exists in the model.");
				}else if(MetaProject.getInstance().getMetaParameter(paramName).getClassNameForExperimentManager() == null){
					throw new RuntimeException("Illegal parameter '"+paramName+"' specified for uncertainty param "+paramNum + ".<br>"+
					"Uncertainty parameters can only be Species parameters, Habitat parameters, or from Model.Setup.");
				}else if(MetaProject.getInstance().getDataType(paramName) == MetaParameter.DataType.FLOAT){
					isInt = false;
				}else if(MetaProject.getInstance().getDataType(paramName) != MetaParameter.DataType.INTEGER){
					throw new RuntimeException("Illegal parameter '"+paramName+"' specified for uncertainty param "+paramNum + ".<br>"+
					"Only parameters of type 'double' or 'integer' can be used in the uncertainty analysis.");
				}
				String paramType = MetaProject.getInstance().getParameterType(paramName);
				String classNameForExperiment = MetaProject.getInstance().getMetaParameter(paramName).getClassNameForExperimentManager();
				Parameter param = null;
				if(classNameForExperiment.equals("FishParams")){
					for(String fish : parent.getOpenProject().getFish()){
						if(paramType.equals("speSetup")){
							param = parent.getOpenProject().getSetupParameters(paramType+"-").getParameter(paramName);
						}else{
							param = parent.getOpenProject().getSetupParameters(paramType+"-"+fish).getParameter(paramName);
						}
						generateUncertaintyValues(param, numUncertScenarios, uncertLow, uncertHigh, isInt, paramNum, totalUncertRuns, uncertaintyData);
					}
				}else if(classNameForExperiment.equals("HabitatSpace")){
					for(String hab : parent.getOpenProject().getHabs()){
						if(paramType.equals("habSetup")){
							param = parent.getOpenProject().getSetupParameters(paramType+"-").getParameter(paramName);
						}else{
							param = parent.getOpenProject().getSetupParameters(paramType+"-"+hab).getParameter(paramName);
						}
						generateUncertaintyValues(param, numUncertScenarios, uncertLow, uncertHigh, isInt, paramNum, totalUncertRuns, uncertaintyData);
					}
				}else if(classNameForExperiment.equals("TroutModelSwarm")){
					param = parent.getOpenProject().getSetupParameters(paramType+"-").getParameter(paramName);
					generateUncertaintyValues(param, numUncertScenarios, uncertLow, uncertHigh, isInt, paramNum, totalUncertRuns, uncertaintyData);
				}
			}

			// Create the new project directories and copy the input files into them
			File lftDir = new File(projectDir+"/LFT");
			if(!lftDir.exists())lftDir.mkdir();
			File newExpDir = null;
			ArrayList<String> filesToCopy = new ArrayList<String>();
			filesToCopy.addAll(project.getAllInfileNames());
			for(String inFilename : MetaProject.getInstance().getStaticFileNames()){
				filesToCopy.add(inFilename);
			}
			for(String hab : project.getHabs()){
				filesToCopy.add(project.getSetupParameters("habParam-"+hab).getFileName());
			}
			for(String spe : project.getFish()){
				filesToCopy.add(project.getSetupParameters("speParam-"+spe).getFileName());
			}
			filesToCopy.add("Experiment.Setup");
			for(LFTExperiment exp : LFTExperiment.values()){
				if(exp == LFTExperiment.NUM_SPAWNERS && !isInsalmo)continue;
				newExpDir = new File(lftDir.getAbsolutePath()+"/"+lftExpToString(exp));
				if(!newExpDir.exists())newExpDir.mkdir();
				ArrayList<String> alreadyCopied = new ArrayList<String>();
				for(String inFilename : filesToCopy){
					if(alreadyCopied.contains(inFilename))continue;
					alreadyCopied.add(inFilename);
					MetaProject.getInstance().copy(new File(projectDir+"/"+inFilename), new File(newExpDir.getAbsolutePath()+"/"+inFilename));
				}
			}
			String dataFilePath = null;
			ArrayList<String> alreadyProcessed = new ArrayList<String>();
			ExperimentParameter expParam = null;
			Integer numColumnsExpected = null;
			Boolean firstInstance = null;
			// Generate and write to file the factor levels associated with each scenario / uncertainty scenario
			ArrayList<ArrayList> factorLevels = new ArrayList<ArrayList>();
			factorLevels.add(new ArrayList<String>());
			String factorLevelHeader = "Scaled Parameter,";
			for(String paramKey : uncertaintyData.keySet()){
				String paramName = ExperimentParameter.getParamNameFromParamKey(paramKey);
				if(!alreadyProcessed.contains(paramName)){
					factorLevels.add(new ArrayList<String>());
					factorLevelHeader += paramName+",";
					alreadyProcessed.add(paramName);
				}
			}
			alreadyProcessed.clear();
			factorLevelHeader = factorLevelHeader.substring(0,factorLevelHeader.length()-1);
			for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
				Double scaledParam = ((Integer)scenarioNum).doubleValue()/(numScenarios-1);
				for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
					factorLevels.get(0).add(scaledParam.toString());
				}
			}
			for(Integer paramNum = 1; paramNum < factorLevels.size(); paramNum++){
				Double modDelay = Math.pow(numUncertScenarios.doubleValue(),((Integer)(paramNum-1)).doubleValue());
				for(Integer runInd = 0; runInd < totalUncertRuns*numScenarios; runInd++){
					Double scaledUncertParam = 0.5;
					if(numUncertScenarios>1)scaledUncertParam = (Math.floor(runInd.doubleValue()/modDelay) % numUncertScenarios.doubleValue())/(numUncertScenarios.doubleValue()-1);
					factorLevels.get(paramNum).add(scaledUncertParam); 
				}
			}
			writeTable(lftDir.getAbsolutePath()+"/LFT_Factor_Levels.csv",factorLevels,factorLevelHeader);
			// Configure each experiment through Experiment.Setup as well as modifying input files when relevant
			for(LFTExperiment exp : LFTExperiment.values()){
				if(exp == LFTExperiment.NUM_SPAWNERS && !isInsalmo)continue;
				newExpDir = new File(lftDir.getAbsolutePath()+"/"+lftExpToString(exp));
				parent.actionHandler.closeProject("Close");
				parent.actionHandler.openProject(newExpDir);
				parent.actionHandler.clearExperiment();
				ArrayList<ExperimentParameter> uncertParams = createUncertaintyParameters(uncertaintyData);
				switch (exp) {
				case WINTER_WATER_TEMP:
				case SUMMER_WATER_TEMP:
					Boolean isWinterExperiment = (exp==LFTExperiment.WINTER_WATER_TEMP);
					String summWint = isWinterExperiment?"winter":"summer";
					dataFilePath = newExpDir.getAbsolutePath()+"/";
					SimpleDateFormat dayFormat = new SimpleDateFormat("MM/dd");
					Integer dayBegin=null, dayEnd=null;
					Double baseRangeLow = null, baseRangeHigh=null;
					try {
						dayBegin = (new Day(dayFormat.parse(lftSetup.getParameter(summWint+"TemperatureStartDay").getParameterValue()))).getDayOfYear();
						dayEnd = (new Day(dayFormat.parse(lftSetup.getParameter(summWint+"TemperatureEndDay").getParameterValue()))).getDayOfYear();
						baseRangeLow = Double.parseDouble(lftSetup.getParameter(summWint+"TemperatureRangeLow").getParameterValue());
						baseRangeHigh = Double.parseDouble(lftSetup.getParameter(summWint+"TemperatureRangeHigh").getParameterValue());
					} catch (ParseException e) {
						e.printStackTrace();
					}
					// The following deals with the fact that the manner in which we use StartDay and EndDay for winter temp. depends on whether the
					// two days straddle the new year (e.g. Nov 1 - Jan 30) or on the "same side" of the new year (e.g. Nov 1 - Dec 30).  To do this 
					// we need to choose a mid-summer day (July 1 or d.o.y. 214 is used below) and check if StartDay and Endy day are both greater than or 
					// less than this day (in which case they are on the same side, otherwise they are not).
					// If this is the summer experiment, we just assume they are on the same side of the new year.
					// The consequence of all this is that the winter is not allowed to straddle mid summer (i.e. winter CANNOT go from Nov 1 - July 30) and
					// summer cannot straddle the new year. 
					int midSummer = 214;
					// Note if the Begin and End days are on the same side of the new year
					Boolean sameSide = null;
					Boolean isSeasonForTempModification = null;
					Boolean isSummer = null;
					if(isWinterExperiment){
						if((dayBegin < midSummer && dayEnd < midSummer) || (dayBegin >= midSummer && dayEnd >= midSummer)){
							// Make sure they are chronological
							if(dayBegin > dayEnd)throw new RuntimeException("Illegal values for winterTemperatureStartDay and winterTemperatureEndDay ("+
									lftSetup.getParameter("winterTemperatureStartDay").getParameterValue()+" and "+lftSetup.getParameter("winterTemperatureEndDay").getParameterValue()+")");
							sameSide = true;
						}else{
							sameSide = false;
						}
					}else{
						sameSide = true;
					}
					alreadyProcessed.clear();
					firstInstance = true;
					for(String hab : project.getHabs()){
						// EXPERIMENT SETUP
						String dataFileName = project.getSetupParameters("habSetup-"+hab).getParameter("temperatureFile").getParameterValue();
						File dataFile = new File(dataFileName);
						parent.actionHandler.addExperimentParamSubmitted("temperatureFile", hab, "HabitatSpace");
						expParam = parent.getOpenProject().getExperimentParameters("temperatureFile ("+hab+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(newDataFileName);
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
						// MODIFY INPUT FILES IF NECESSARY
						if(alreadyProcessed.contains(dataFileName))continue;
						alreadyProcessed.add(dataFileName);
						ArrayList<ArrayList> timeSeries = parseTimeSeriesFile(dataFilePath+dataFileName);
						ArrayList<Day> dates = timeSeries.get(0);
						ArrayList<Double> data = timeSeries.get(1);
						ArrayList<ArrayList> newTimeSeries = new ArrayList<ArrayList>();
						ArrayList<Double> constantTempAdder = new ArrayList<Double>();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							ArrayList<ArrayList> newTS = new ArrayList<ArrayList>();
							newTS.add(new ArrayList<Day>());
							newTS.add(new ArrayList<Double>());
							newTimeSeries.add(newTS);
							constantTempAdder.add(baseRangeLow + (baseRangeHigh-baseRangeLow)*(scenarioNum)/(numScenarios-1));
						}
						for(int i=0; i<dates.size(); i++){
							Double existingValue = data.get(i);
							Integer beginLeapAdder = 0, endLeapAdder = 0;
							if(sameSide){
								if(dates.get(i).isLeapYear()){
									if(dayBegin>=60)beginLeapAdder = 1;
									if(dayEnd>=60)endLeapAdder = 1;
								}
								isSeasonForTempModification = (dates.get(i).getDayOfYear() >= dayBegin+beginLeapAdder && dates.get(i).getDayOfYear() <= dayEnd+endLeapAdder);
							}else{
								if(dates.get(i).getDayOfYear() < midSummer){
									if(dates.get(i).isLeapYear()){
										if(dayEnd>=60)endLeapAdder = 1;
									}
								}else{
									if(dates.get(i).isLeapYear()){
										if(dayBegin>=60)beginLeapAdder = 1;
									}
								}
								isSeasonForTempModification = (dates.get(i).getDayOfYear() <= dayEnd+endLeapAdder || dates.get(i).getDayOfYear() >= dayBegin+beginLeapAdder);
							}
							for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
								((ArrayList<Day>) newTimeSeries.get(scenarioNum).get(0)).add(dates.get(i));
								if(isSeasonForTempModification){
									Double newValue = existingValue+constantTempAdder.get(scenarioNum);
									((ArrayList<Double>) newTimeSeries.get(scenarioNum).get(1)).add((newValue>0)?newValue:0);	
								}else{
									((ArrayList<Double>) newTimeSeries.get(scenarioNum).get(1)).add(existingValue);
								}
							}
						}
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							writeTimeSeriesFile(dataFilePath+newDataFileName,newTimeSeries.get(scenarioNum));
						}
					}
					break;
				case BASE_FLOW:
					dataFilePath = newExpDir.getAbsolutePath()+"/";
					Double baseFlowRangeLow = null, baseFlowRangeHigh=null;
					baseRangeLow = Double.parseDouble(lftSetup.getParameter("baseFlowRangeLow").getParameterValue());
					baseRangeHigh = Double.parseDouble(lftSetup.getParameter("baseFlowRangeHigh").getParameterValue());
					alreadyProcessed.clear();
					firstInstance = true;
					for(String hab : project.getHabs()){
						// EXPERIMENT SETUP
						String dataFileName = project.getSetupParameters("habSetup-"+hab).getParameter("flowFile").getParameterValue();
						File dataFile = new File(dataFileName);
						parent.actionHandler.addExperimentParamSubmitted("flowFile", hab, "HabitatSpace");
						expParam = parent.getOpenProject().getExperimentParameters("flowFile ("+hab+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(newDataFileName);
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
						// MODIFY INPUT FILES IF NECESSARY
						if(alreadyProcessed.contains(dataFileName))continue;
						alreadyProcessed.add(dataFileName);
						ArrayList<ArrayList> timeSeries = parseTimeSeriesFile(dataFilePath+dataFileName);
						ArrayList<Day> dates = timeSeries.get(0);
						ArrayList<Double> data = timeSeries.get(1);
						ArrayList<ArrayList> newTimeSeries = new ArrayList<ArrayList>();
						ArrayList<Double> constantBaseAdder = new ArrayList<Double>();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							ArrayList<ArrayList> newTS = new ArrayList<ArrayList>();
							newTS.add(new ArrayList<Day>());
							newTS.add(new ArrayList<Double>());
							newTimeSeries.add(newTS);
							constantBaseAdder.add(baseRangeLow + (baseRangeHigh-baseRangeLow)*(scenarioNum)/(numScenarios-1));
						}
						for(int i=0; i<dates.size(); i++){
							for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
								((ArrayList<Day>) newTimeSeries.get(scenarioNum).get(0)).add(dates.get(i));
								Double newValue = data.get(i)+constantBaseAdder.get(scenarioNum);
								if(newValue < 0){
									if(!isInsalmo){
										throw new RuntimeException("In BASE_FLOW experiment, the sum of baseFlowRangeLow and the standard flow is less than zero making the flow negative.  This is not permitted, stopping LFT.");
									}else{
										newValue = 0.1;
									}
								}
								((ArrayList<Double>) newTimeSeries.get(scenarioNum).get(1)).add(newValue);
							}
						}
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							writeTimeSeriesFile(dataFilePath+newDataFileName,newTimeSeries.get(scenarioNum));
						}
					}
					break;
				case SPAWNING_GRAVEL_AVAIL:
				case VELOCITY_SHELTER_AVAIL:
					Boolean isGravelExperiment = (exp==LFTExperiment.SPAWNING_GRAVEL_AVAIL);
					String gravelOrShelter = isGravelExperiment ? "gravel" : "shelter";
					int columnToMod = isGravelExperiment ? 3 : 1;
					numColumnsExpected = 5;
					dataFilePath = newExpDir.getAbsolutePath()+"/";
					Double rangeLow = null, rangeHigh=null;
					rangeLow = Double.parseDouble(lftSetup.getParameter(gravelOrShelter + "AvailabilityRangeLow").getParameterValue());
					rangeHigh = Double.parseDouble(lftSetup.getParameter(gravelOrShelter + "AvailabilityRangeHigh").getParameterValue());
					alreadyProcessed.clear();
					firstInstance = true;
					for(String hab : project.getHabs()){
						// EXPERIMENT SETUP
						String dataFileName = project.getSetupParameters("habSetup-"+hab).getParameter("cellHabVarsFile").getParameterValue();
						File dataFile = new File(dataFileName);
						parent.actionHandler.addExperimentParamSubmitted("cellHabVarsFile", hab, "HabitatSpace");
						expParam = parent.getOpenProject().getExperimentParameters("cellHabVarsFile ("+hab+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(newDataFileName);
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
						// MODIFY INPUT FILES IF NECESSARY
						if(alreadyProcessed.contains(dataFileName))continue;
						alreadyProcessed.add(dataFileName);
						ArrayList<Integer> doubleColumnInds = new ArrayList<Integer>();
						doubleColumnInds.add(columnToMod);
						ArrayList<ArrayList> cellHabData = readTable(dataFilePath+dataFileName, 3, doubleColumnInds, new ArrayList<Integer>(), numColumnsExpected);
						ArrayList<ArrayList> newTimeSeries = new ArrayList<ArrayList>();
						ArrayList<Double> constantG = new ArrayList<Double>();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							ArrayList<ArrayList> newTS = new ArrayList<ArrayList>();
							for(int columnInd = 0; columnInd < numColumnsExpected; columnInd++){
								if(columnInd!=columnToMod){
									newTS.add(new ArrayList<String>());
								}else{
									newTS.add(new ArrayList<Double>());
								}
							}
							newTimeSeries.add(newTS);
							constantG.add(rangeLow + (rangeHigh - rangeLow)*(scenarioNum)/(numScenarios-1));
						}
						for(int i=0; i<cellHabData.get(0).size(); i++){
							for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
								for(int columnInd = 0; columnInd < 5; columnInd++){
									if(columnInd != columnToMod){
										((ArrayList) newTimeSeries.get(scenarioNum).get(columnInd)).add(cellHabData.get(columnInd).get(i));
									}
								}
								Double newValue = (Double) cellHabData.get(columnToMod).get(i);
								if(constantG.get(scenarioNum)<1.0){
									newValue = newValue * constantG.get(scenarioNum);
									if(newValue > 0.0 && Math.random() < (1.0-constantG.get(scenarioNum))){
										newValue = 0.0;
									}
								}else if(constantG.get(scenarioNum)>1.0){
									newValue = newValue * constantG.get(scenarioNum);
									newValue = (newValue > 1.0) ? 1.0 : newValue;
									if(newValue == 0.0 && Math.random() < (constantG.get(scenarioNum)-1.0)){
										newValue = 0.5;
									}
								}
								((ArrayList<Double>) newTimeSeries.get(scenarioNum).get(columnToMod)).add(newValue);
							}
						}
						String header = "# Cell Habitat Data File Automatically Generated by Limiting Factors Tool"+newline+newline+
						"CellNum,FracVelocityShelter,DistToHidingCover,FracSpawnGravel,ReachEndCode";
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							writeTable(dataFilePath+newDataFileName,newTimeSeries.get(scenarioNum),header);
						}
					}
					break;
				case HIDING_COVER_AVAIL:
					columnToMod = 2;
					dataFilePath = newExpDir.getAbsolutePath()+"/";
					Double hideRangeLow = null, hideRangeHigh=null, hideThresh=null;
					hideRangeLow = Double.parseDouble(lftSetup.getParameter("hidingCoverRangeLow").getParameterValue());
					hideRangeHigh = Double.parseDouble(lftSetup.getParameter("hidingCoverRangeHigh").getParameterValue());
					hideThresh = Double.parseDouble(lftSetup.getParameter("hidingCoverThreshold").getParameterValue());
					alreadyProcessed.clear();
					firstInstance = true;
					for(String hab : project.getHabs()){
						// EXPERIMENT SETUP
						String dataFileName = project.getSetupParameters("habSetup-"+hab).getParameter("cellHabVarsFile").getParameterValue();
						File dataFile = new File(dataFileName);
						parent.actionHandler.addExperimentParamSubmitted("cellHabVarsFile", hab, "HabitatSpace");
						expParam = parent.getOpenProject().getExperimentParameters("cellHabVarsFile ("+hab+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(newDataFileName);
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
						// MODIFY INPUT FILES IF NECESSARY
						if(alreadyProcessed.contains(dataFileName))continue;
						alreadyProcessed.add(dataFileName);
						ArrayList<Integer> doubleColumnInds = new ArrayList<Integer>();
						doubleColumnInds.add(columnToMod);
						ArrayList<ArrayList> cellHabData = readTable(dataFilePath+dataFileName, 3, doubleColumnInds, new ArrayList<Integer>(), numColumnsExpected);
						ArrayList<ArrayList> newTimeSeries = new ArrayList<ArrayList>();
						ArrayList<Double> constantH = new ArrayList<Double>();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							ArrayList<ArrayList> newTS = new ArrayList<ArrayList>();
							for(int columnInd = 0; columnInd < numColumnsExpected; columnInd++){
								if(columnInd!=columnToMod){
									newTS.add(new ArrayList<String>());
								}else{
									newTS.add(new ArrayList<Double>());
								}
							}
							newTimeSeries.add(newTS);
							constantH.add(hideRangeLow + (hideRangeHigh - hideRangeLow)*(scenarioNum)/(numScenarios-1));
						}
						for(int i=0; i<cellHabData.get(0).size(); i++){
							for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
								for(int columnInd = 0; columnInd < 5; columnInd++){
									if(columnInd != columnToMod){
										((ArrayList) newTimeSeries.get(scenarioNum).get(columnInd)).add(cellHabData.get(columnInd).get(i));
									}
								}
								Double newValue = (Double) cellHabData.get(columnToMod).get(i);
								if(constantH.get(scenarioNum)<1.0){
									if(constantH.get(scenarioNum)>0.0){
										newValue = newValue / constantH.get(scenarioNum);
									}else{
										newValue = 99.0;
									}
								}else if(constantH.get(scenarioNum)>1.0){
									newValue = newValue / constantH.get(scenarioNum);
									if(newValue > hideThresh && Math.random() < (constantH.get(scenarioNum) - 1.0)){
										newValue = hideThresh * 0.5;
									}
								}
								((ArrayList<Double>) newTimeSeries.get(scenarioNum).get(columnToMod)).add(newValue);
							}
						}
						String header = "# Cell Habitat Data File Automatically Generated by Limiting Factors Tool"+newline+newline+
						"CellNum,FracVelocityShelter,DistToHidingCover,FracSpawnGravel,ReachEndCode";
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
							writeTable(dataFilePath+newDataFileName,newTimeSeries.get(scenarioNum),header);
						}
					}
					break;
				case PISCIVORY_RISK:
					Double piscRiskLow = Double.parseDouble(lftSetup.getParameter("piscivoryRiskRatioLow").getParameterValue());
					Double piscRiskHigh = Double.parseDouble(lftSetup.getParameter("piscivoryRiskRatioHigh").getParameterValue());
					firstInstance = true;
					for(String spe : project.getFish()){
						Double baseRisk = Double.parseDouble(parent.getOpenProject().getSetupParameters("speParam-"+spe).getParameter("mortFishAqPredMin").getParameterValue());
						parent.actionHandler.addExperimentParamSubmitted("mortFishAqPredMin", spe, "FishParams");
						expParam = parent.getOpenProject().getExperimentParameters("mortFishAqPredMin ("+spe+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							Double newRisk = (piscRiskLow + (piscRiskHigh - piscRiskLow)*(scenarioNum)/(numScenarios-1));
							Double newValue = (1.0 - (1.0 - baseRisk) * newRisk);
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(newValue.toString());
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
					}
					break;
				case FOOD_AVAIL:
					Double foodAvailabilityRatioLow = Double.parseDouble(lftSetup.getParameter("foodAvailabilityRatioLow").getParameterValue());
					Double foodAvailabilityRatioHigh = Double.parseDouble(lftSetup.getParameter("foodAvailabilityRatioHigh").getParameterValue());
					ExperimentParameter expParamConc = null;
					ExperimentParameter expParamProd = null;
					firstInstance = true;
					for(String hab : project.getHabs()){
						Double baseConc = Double.parseDouble(parent.getOpenProject().getSetupParameters("habParam-"+hab).getParameter("habDriftConc").getParameterValue());
						Double baseProd = Double.parseDouble(parent.getOpenProject().getSetupParameters("habParam-"+hab).getParameter("habSearchProd").getParameterValue());
						parent.actionHandler.addExperimentParamSubmitted("habDriftConc", hab, "HabitatSpace");
						parent.actionHandler.addExperimentParamSubmitted("habSearchProd", hab, "HabitatSpace");
						expParamConc = parent.getOpenProject().getExperimentParameters("habDriftConc ("+hab+")");
						expParamProd = parent.getOpenProject().getExperimentParameters("habSearchProd ("+hab+")");
						expParamConc.getValues().clear();
						expParamProd.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							Double newRatio = (foodAvailabilityRatioLow + (foodAvailabilityRatioHigh - foodAvailabilityRatioLow)*(scenarioNum)/(numScenarios-1));
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParamConc.addValue(((Double)(baseConc*newRatio)).toString());
								expParamProd.addValue(((Double)(baseProd*newRatio)).toString());
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
					}
					break;
				case REDD_SCOURING:
					Double reddScourRatioLow = Double.parseDouble(lftSetup.getParameter("reddScourRatioLow").getParameterValue());
					Double reddScourRatioHigh = Double.parseDouble(lftSetup.getParameter("reddScourRatioHigh").getParameterValue());
					firstInstance = true;
					for(String spe : project.getFish()){
						Double baseDepth = Double.parseDouble(parent.getOpenProject().getSetupParameters("speParam-"+spe).getParameter("mortReddScourDepth").getParameterValue());
						parent.actionHandler.addExperimentParamSubmitted("mortReddScourDepth", spe, "FishParams");
						expParam = parent.getOpenProject().getExperimentParameters("mortReddScourDepth ("+spe+")");
						expParam.getValues().clear();
						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
							Double newRatio = (reddScourRatioLow + (reddScourRatioHigh - reddScourRatioLow)*(scenarioNum)/(numScenarios-1));
							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
								expParam.addValue(((Double)(baseDepth * newRatio)).toString());
								// the following should only happen once, not for each reach or species
								if(firstInstance){
									for(ExperimentParameter uncertParam : uncertParams){
										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
									}
								}
							}
						}
						firstInstance = false;
					}
					break;
				case NUM_SPAWNERS:
					Double spawnerNumberRatioLow = Double.parseDouble(lftSetup.getParameter("spawnerNumberRatioLow").getParameterValue());
					Double spawnerNumberRatioHigh = Double.parseDouble(lftSetup.getParameter("spawnerNumberRatioHigh").getParameterValue());
					parent.actionHandler.addExperimentParamSubmitted("numSpawnerAdjuster", "NONE", "TroutModelSwarm");
					expParam = parent.getOpenProject().getExperimentParameters("numSpawnerAdjuster (ALL)");
					expParam.getValues().clear();
					for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
						Double newRatio = (spawnerNumberRatioLow + (spawnerNumberRatioHigh - spawnerNumberRatioLow)*(scenarioNum)/(numScenarios-1));
						for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
							expParam.addValue(newRatio.toString());
							for(ExperimentParameter uncertParam : uncertParams){
								uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
							}
						}
					}
					break;	
//				ORIGNIAL NUM SPAWNERS CODE WHICH MODIFIED THE SPAWNER FILE, NOW A PARAMETER numSpawnerAdjuster is used	
//				case NUM_SPAWNERS:
//					columnToMod = 2;
//					numColumnsExpected = 9;
//					dataFilePath = newExpDir.getAbsolutePath()+"/";
//					Double spawnerNumberRatioLow = Double.parseDouble(lftSetup.getParameter("spawnerNumberRatioLow").getParameterValue());
//					Double spawnerNumberRatioHigh = Double.parseDouble(lftSetup.getParameter("spawnerNumberRatioHigh").getParameterValue());
//					alreadyProcessed.clear();
//					firstInstance = true;
//					for(String spe : project.getFish()){
//						// EXPERIMENT SETUP
//						String dataFileName = project.getSetupParameters("speSetup-"+spe).getParameter("speciesInitPopFile").getParameterValue();
//						File dataFile = new File(dataFileName);
//						parent.addExperimentParamSubmitted("speciesInitPopFile", spe, "FishParams");
//						expParam = parent.getOpenProject().getExperimentParameters("speciesInitPopFile ("+spe+")");
//						expParam.getValues().clear();
//						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
//							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
//							for(int uncertInd = 0; uncertInd < totalUncertRuns; uncertInd++){
//								expParam.addValue(newDataFileName);
//								// the following should only happen once, not for each reach or species
//								if(firstInstance){
//									for(ExperimentParameter uncertParam : uncertParams){
//										uncertParam.addValue(uncertaintyData.get(uncertParam.getParamKey()).get(uncertInd));
//									}
//								}
//							}
//						}
//						firstInstance = false;
//						// MODIFY INPUT FILES IF NECESSARY
//						if(alreadyProcessed.contains(dataFileName))continue;
//						alreadyProcessed.add(dataFileName);
//						ArrayList<Integer> doubleColumnInds = new ArrayList<Integer>();
//						doubleColumnInds.add(columnToMod);
//						ArrayList<ArrayList> spawnerInitData = readTable(dataFilePath+dataFileName,3,doubleColumnInds,new ArrayList<Integer>(),9);
//						Integer numRows = spawnerInitData.get(0).size();
//						ArrayList<ArrayList> newTimeSeries = new ArrayList<ArrayList>();
//						ArrayList<Double> constantRatio = new ArrayList<Double>();
//						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
//							ArrayList<ArrayList> newTS = new ArrayList<ArrayList>();
//							for(int columnInd = 0; columnInd < numColumnsExpected; columnInd++){
//								if(columnInd!=columnToMod){
//									newTS.add(new ArrayList<String>());
//								}else{
//									newTS.add(new ArrayList<Double>());
//								}
//							}
//							newTimeSeries.add(newTS);
//							constantRatio.add(spawnerNumberRatioLow + (spawnerNumberRatioHigh - spawnerNumberRatioLow)*(scenarioNum)/(numScenarios-1));
//						}
//						for(int rowInd=0; rowInd<numRows; rowInd++){
//							for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
//								for(int columnInd = 0; columnInd < numColumnsExpected; columnInd++){
//									if(columnInd != columnToMod){
//										((ArrayList) newTimeSeries.get(scenarioNum).get(columnInd)).add(spawnerInitData.get(columnInd).get(rowInd));
//									}else{
//										Double newValue = constantRatio.get(scenarioNum)*((Double)spawnerInitData.get(columnInd).get(rowInd));
//										((ArrayList) newTimeSeries.get(scenarioNum).get(columnInd)).add(newValue.intValue());
//									}
//								}
//							}
//						}
//						String header = "# Spawner Initialization File Automatically Generated by Limiting Factors Tool"+newline+newline+
//						"Year,Arrival reach,Number of spawners,Fraction female,Arrival start date,Arrival end date,Arrival ratio,Female length mean,Female length SD";
//						for(int scenarioNum = 0; scenarioNum < numScenarios; scenarioNum++ ){
//							String newDataFileName = getNameWithoutExtension(dataFile)+"-LFT-"+scenarioNum+".csv";
//							writeTable(dataFilePath+newDataFileName,newTimeSeries.get(scenarioNum),header);
//						}
//					}
//					break;

				default:
					break;
				}
				parent.getOpenProject().setNumberOfScenarios();
				parent.actionHandler.saveProject();
				parent.actionHandler.closeProject("Close");
				parent.actionHandler.openProject(new File(projectDir));
			}
			return true;
		}else{
			return false;
		}
	}
	private ArrayList<ExperimentParameter> createUncertaintyParameters(Hashtable<String,ArrayList<String>> uncertaintyData){
		ArrayList<ExperimentParameter> result = new ArrayList<ExperimentParameter>();
		for(String paramKey : uncertaintyData.keySet()){
			String paramName = ExperimentParameter.getParamNameFromParamKey(paramKey);
			String instanceName = ExperimentParameter.getParamInstanceFromParamKey(paramKey);
			parent.actionHandler.addExperimentParamSubmitted(paramName, instanceName, MetaProject.getInstance().getMetaParameter(paramName).getClassNameForExperimentManager());
			ExperimentParameter expParam = parent.getOpenProject().getExperimentParameters(paramName + " ("+instanceName+")");
			expParam.getValues().clear();
			result.add(expParam);
		}
		return result;
	}
	private  void generateUncertaintyValues(Parameter param, Integer numUncertScenarios, Double uncertLow, Double uncertHigh, boolean isInt, int paramNum, Integer totalUncertRuns, 
			Hashtable<String, ArrayList<String>> uncertaintyData){
		String instanceName = ((SetupParameters)param.getSource()).getParamInstance();
		String paramName = param.getParameterName();
		ArrayList paramValues = new ArrayList<String>(), allParamValues = new ArrayList<String>();
		Double newVal = null;
		for(Integer scenInd = 0; scenInd < numUncertScenarios; scenInd++){
			if(numUncertScenarios==1){
				newVal = 1.0;
			}else{
				newVal = uncertLow + (uncertHigh-uncertLow)*(scenInd.doubleValue()/(numUncertScenarios.doubleValue()-1.0));
			}
			if(isInt){
				newVal = newVal * param.getParameterIntegerValue().doubleValue();
				paramValues.add(((Integer)((Long)Math.round(newVal)).intValue()).toString());
			}else{
				newVal = newVal * Double.parseDouble(param.getParameterValue());
				paramValues.add(newVal.toString());
			}
		}
		Double modDelay = Math.pow(numUncertScenarios.doubleValue(),((Integer)(paramNum-1)).doubleValue());
		for(Integer runInd = 0; runInd < totalUncertRuns; runInd++){
			int scenarioInd = ((Double)(runInd.doubleValue()/modDelay)).intValue() % numUncertScenarios;
			allParamValues.add(paramValues.get(scenarioInd)); 
		}
		String paramKey = null;
		if(instanceName.equals("NONE")){
			paramKey = paramName+" (ALL)";
		}else{
			paramKey = paramName+" ("+instanceName+")";
		}
		uncertaintyData.put(paramKey, allParamValues);
	}
	public String postProcessResults() throws FileNotFoundException, IOException, ParseException {
		String projectDir = parent.getOpenProject().getProjectDirectory().getAbsolutePath();
		File lftDir = new File(projectDir+"/LFT");
		if(!lftDir.exists()){
			throw new FileNotFoundException("Error - Limiting Factors Tool has not been executed for this project, cannot find directory: <br>"+
					lftDir.getAbsolutePath());
		}
		String factorLevelsFilename = lftDir.getAbsoluteFile()+"/LFT_Factor_Levels.csv";
		String resultsHeader = "RunNumber,Experiment Name,Scaled Parameter Value";
		if(!isInsalmo){
			resultsHeader += ",Mean Number of Adults,Mean Biomass of All Adults,";
		}else{
			resultsHeader += ",Number of Outmigrants,Number of Outmigrants >5cm,";
		}
		ArrayList<ArrayList> factorLevels = readTable(factorLevelsFilename,0);
		ArrayList<ArrayList> lftConsolidated = new ArrayList<ArrayList>();
		lftConsolidated.add(new ArrayList<String>());
		lftConsolidated.add(new ArrayList<String>());
		lftConsolidated.add(new ArrayList<String>());
		lftConsolidated.add(new ArrayList<String>());
		lftConsolidated.add(new ArrayList<String>());
		for(int i=1; i<=3; i++){
			if(i<factorLevels.size()){
				lftConsolidated.add(new ArrayList<String>());
				resultsHeader += factorLevels.get(i).get(0)+",";
			}else{
				resultsHeader += "Dummy Param "+i+",";
			}
		}
		resultsHeader = resultsHeader.substring(0,resultsHeader.length()-1);
		String exceptionMessages = "";
		int modelRunInd = 1;
		int expectedColumns = isInsalmo ? 4 : 5;
		for(LFTExperiment exp : LFTExperiment.values()){
			if(exp == LFTExperiment.NUM_SPAWNERS && !isInsalmo)continue;
			File expDir = new File(lftDir.getAbsolutePath()+"/"+lftExpToString(exp));
			if(!expDir.exists()){
				throw new FileNotFoundException("Error - LFT Experiment has not been executed for this project, cannot find directory: <br>"+
						expDir.getAbsolutePath());
			}
			try{
				ArrayList<ArrayList> expOutput = readTable(expDir.getAbsolutePath()+"/LFT_Output.rpt",3,new ArrayList<Integer>(),new ArrayList<Integer>(),expectedColumns);
				for(int i=0; i<expOutput.get(0).size(); i++){
					lftConsolidated.get(0).add(modelRunInd++);
					lftConsolidated.get(1).add(lftExpToString(exp));
					lftConsolidated.get(2).add(factorLevels.get(0).get(i+1));
					lftConsolidated.get(3).add(expOutput.get(expectedColumns-2).get(i));
					lftConsolidated.get(4).add(expOutput.get(expectedColumns-1).get(i));
					for(int j=1; j<factorLevels.size(); j++){
						lftConsolidated.get(j+4).add(factorLevels.get(j).get(i+1));
					}
				}
			}catch(Exception e){
				exceptionMessages += "<br>"+e.getMessage();
			}
		}
		writeTable(projectDir+"/LFT_Raw_Results.csv", lftConsolidated, resultsHeader);
		return exceptionMessages;
	}
	public  ArrayList<ArrayList> parseTimeSeriesFile(String filename) throws FileNotFoundException,IOException,ParseException{
		ArrayList<Day> dates = new ArrayList<Day>();
		ArrayList<Double> data = new ArrayList<Double>();
		ArrayList<ArrayList> result = new ArrayList<ArrayList>();
		result.add(dates);
		result.add(data);

		File dataFile = new File(filename);
		FileInputStream fstream = new FileInputStream(dataFile);
		DataInputStream in = new DataInputStream(fstream);
		BufferedReader br = new BufferedReader(new InputStreamReader(in));
		int lineCount = 0;
		String delim = null, strLine = null;
		String[] lineData;
		SimpleDateFormat timeSeriesDateFormat = new SimpleDateFormat("MM/dd/yyyy");

		while ((strLine = br.readLine())!=null){
			if(lineCount++<3)continue;
			if(delim==null){
				Boolean hasTab = strLine.contains("\t");
				Boolean hasCom = strLine.contains(",");
				if(hasTab && hasCom){
					throw new IOException("Ambiguous file format in file "+dataFile+", line "+lineCount+" contains both a tab and a comma character, expecting one or the other.");
				}else if(hasTab){
					delim = "\t";
				}else if(hasCom){
					delim = ",";
				}else{
					throw new IOException("Illegal file format in file "+dataFile+", line "+lineCount+" does not contain a tab or a comma character, expecting one or the other.");
				}
			}
			lineData = strLine.split(delim);
			if(lineData.length<2){
				throw new IOException("Missing data in file "+dataFile+", line "+lineCount+" contains less than 2 values, expecting 2.");
			}
			dates.add(new Day(timeSeriesDateFormat.parse(lineData[0])));
			data.add(Double.parseDouble(lineData[1]));
		}
		return result;
	}
	public  ArrayList<ArrayList> readTable(String filename, Integer skipRows) throws FileNotFoundException,IOException,ParseException{
		return readTable(filename, skipRows, new ArrayList<Integer>(), new ArrayList<Integer>(), 0);
	}
	public  ArrayList<ArrayList> readTable(String filename, Integer skipRows, ArrayList<Integer> doubleColumnInds, ArrayList<Integer> integerColumnInds) throws FileNotFoundException,IOException,ParseException{
		return readTable(filename, skipRows, doubleColumnInds, integerColumnInds, 0);
	}
	public  ArrayList<ArrayList> readTable(String filename, Integer skipRows, ArrayList<Integer> doubleColumnInds, ArrayList<Integer> integerColumnInds, Integer numColumnsExpected) throws FileNotFoundException,IOException,ParseException{
		ArrayList<ArrayList> result = new ArrayList<ArrayList>();
		File dataFile = new File(filename);
		FileInputStream fstream = new FileInputStream(dataFile);
		DataInputStream in = new DataInputStream(fstream);
		BufferedReader br = new BufferedReader(new InputStreamReader(in));
		int lineCount = 0;
		String delim = null, strLine = null;
		String[] lineData;

		while ((strLine = br.readLine())!=null){
			if(lineCount++<skipRows)continue;
			if(delim==null){
				Boolean hasTab = strLine.contains("\t");
				Boolean hasCom = strLine.contains(",");
				if(hasTab && hasCom){
					throw new IOException("Ambiguous file format in file "+dataFile+", line "+lineCount+" contains both a tab and a comma character, expecting one or the other.");
				}else if(hasTab){
					delim = "\t";
				}else if(hasCom){
					delim = ",";
				}else{
					throw new IOException("Illegal file format in file "+dataFile+", line "+lineCount+" does not contain a tab or a comma character, expecting one or the other.");
				}
				if(numColumnsExpected<1){
					numColumnsExpected = strLine.split(delim).length;
				}
				for(Integer i=0; i<numColumnsExpected; i++){
					if(doubleColumnInds.contains(i)){
						result.add(new ArrayList<Double>());
					}else if(integerColumnInds.contains(i)){
						result.add(new ArrayList<Integer>());
					}else{
						result.add(new ArrayList<String>());
					}	
				}
			}
			lineData = strLine.split(delim);
			if(lineData.length != numColumnsExpected){
				throw new IOException("Unexpected or missing data in file "+dataFile+", line "+lineCount+" contains "+lineData.length+" values, expecting "+numColumnsExpected+".");
			}
			for(Integer i=0; i<numColumnsExpected; i++){
				if(doubleColumnInds.contains(i)){
					result.get(i).add(Double.parseDouble(lineData[i]));
				}else if(integerColumnInds.contains(i)){
					result.get(i).add(Integer.parseInt(lineData[i]));
				}else{
					result.get(i).add(lineData[i]);
				}	
			}
		}
		return result;
	}
	public  void writeTimeSeriesFile(String filename,ArrayList<ArrayList> timeSeries){
		ArrayList<Day> dates = timeSeries.get(0);
		ArrayList<Double> data = timeSeries.get(1);

		try {
			FileOutputStream fstream = new FileOutputStream(filename);
			DataOutputStream out = new DataOutputStream(fstream);
			BufferedWriter br = new BufferedWriter(new OutputStreamWriter(out));

			br.write("# Time Series Data File Automatically Generated by Limiting Factors Tool"+newline+newline);
			br.write("Date,Value"+newline);
			for(int i = 0; i < dates.size(); i++){
				if(i==25139){
					int j = 0;
				}
				br.write(dates.get(i).toInSALMODateString()+","+data.get(i).toString()+newline);
			}
			br.close();
			out.close();
			fstream.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	public  void writeTable(String filename,ArrayList<ArrayList> tableData) throws FileNotFoundException,IOException{
		writeTable(filename,tableData,null,",");
	}
	public  void writeTable(String filename,ArrayList<ArrayList> tableData, String header) throws FileNotFoundException,IOException{
		writeTable(filename,tableData,header,",");
	}
	public  void writeTable(String filename,ArrayList<ArrayList> tableData,String header,String delim) throws FileNotFoundException,IOException{
		FileOutputStream fstream = new FileOutputStream(filename);
		DataOutputStream out = new DataOutputStream(fstream);
		BufferedWriter br = new BufferedWriter(new OutputStreamWriter(out));

		if(header!=null)br.write(header+newline);
		for(int rowInd = 0; rowInd < tableData.get(0).size(); rowInd++){
			for(int colInd = 0; colInd < tableData.size(); colInd++){
				if(colInd==0){
					br.write(((Object)tableData.get(colInd).get(rowInd)).toString());
				}else{
					br.write(delim+tableData.get(colInd).get(rowInd));
				}
			}
			br.write(newline);
		}
		br.close();
		out.close();
		fstream.close();
	}
	public  String lftExpToString(LFTExperiment exp){
		switch (exp) {
		case WINTER_WATER_TEMP:
			return "WINTER_WATER_TEMP";
		case SUMMER_WATER_TEMP:
			return "SUMMER_WATER_TEMP";
		case BASE_FLOW:
			return "BASE_FLOW";
		case SPAWNING_GRAVEL_AVAIL:
			return "SPAWNING_GRAVEL_AVAIL";
		case VELOCITY_SHELTER_AVAIL:
			return "VELOCITY_SHELTER_AVAIL";
		case HIDING_COVER_AVAIL:
			return "HIDING_COVER_AVAIL";
		case PISCIVORY_RISK:
			return "PISCIVORY_RISK";
		case FOOD_AVAIL:
			return "FOOD_AVAIL";
		case REDD_SCOURING:
			return "REDD_SCOURING";
		case NUM_SPAWNERS:
			return "NUM_SPAWNERS";
		default:
			return "";
		}
	}
	private  String getExtension(File f){
		String[] broke = f.getName().split("\\.");
		return broke[broke.length-1];
	}
	private  String getNameWithoutExtension(File f){
		String[] broke = f.getName().split("\\.");
		String result = "";
		for(int i=0; i < broke.length-1; i++){
			result += broke[i];
		}
		return result;
	}
	public  void createLFTOutputTabs(JTabbedPane tabbedPane){
		parent.lftTextAreas.clear();
		for(LFTExperiment exp : LFTExperiment.values()){
			if(exp == LFTExperiment.NUM_SPAWNERS && !isInsalmo)continue;
			String expName = lftExpToString(exp);
			JLabel expLabel = new JLabel();
			expLabel.setText(expName); 
			expLabel.setName(expName+"_Label"); 

			JButton terminateButton = new JButton();
			terminateButton.setText("Terminate "+expName);
			terminateButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
			terminateButton.setName(expName);
			terminateButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
			if(terminateButton.getActionListeners().length==0){
				terminateButton.addActionListener(new TerminateListener(parent));
			}
			JExpandableTextArea textArea = new JExpandableTextArea(30,70);
			textArea.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));
			textArea.setEditable(false);
			textArea.setName(expName);
			((DefaultCaret)textArea.getCaret()).setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);
			parent.lftTextAreas.put(expName,textArea);
			JScrollPane scrollPane = new JScrollPane(textArea);
			scrollPane.setName(expName);
			JPanel pane = new JPanel();
			GroupLayout paneLayout = new GroupLayout(pane);
			pane.setName(expName);
			pane.setVisible(true);
			paneLayout.setHorizontalGroup(
					paneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
					.addGroup(paneLayout.createSequentialGroup()
							.addContainerGap()
							.addGroup(paneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
									.addComponent(scrollPane) 
									.addComponent(terminateButton))
							.addContainerGap())
			);
			paneLayout.setVerticalGroup(
					paneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
					.addGroup(paneLayout.createSequentialGroup()
							.addContainerGap()
							.addComponent(scrollPane)
							.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
							.addComponent(terminateButton)
							.addContainerGap())
			);
			tabbedPane.addTab(pane.getName(), pane); 
		}
	}
	public  void executeLFT() throws Exception{
		for(LFTExperiment exp : LFTExperiment.values()){
			if(exp == LFTExperiment.NUM_SPAWNERS && !isInsalmo)continue;
			String expName = lftExpToString(exp);
			String projDir = parent.getProjectDir().getAbsolutePath();
			// launch EXE and grab stdout and stderr
			LaunchInsamloExecutable launcher = new LaunchInsamloExecutable(projDir+"/LFT/"+expName,parent,false,true,parent.lftTextAreas.get(expName),expName);
			StreamGobbler s1 = new StreamGobbler ("stdout", launcher.getProcess().getInputStream(),parent.lftTextAreas.get(expName),projDir+"/LFT/"+expName+"/Console_Output.Out",newline);
			StreamGobbler s2 = new StreamGobbler ("stderr", launcher.getProcess().getErrorStream(),parent.lftTextAreas.get(expName),projDir+"/LFT/"+expName+"/Console_Output.Out",newline);
			s1.start ();
			s2.start ();
			parent.lftLaunchers.put(expName, launcher);
		}
	}
	public Boolean getTerminatedForcefully() {
		return terminatedForcefully;
	}
	public void setTerminatedForcefully(Boolean terminatedForcefully) {
		this.terminatedForcefully = terminatedForcefully;
	}
	public String getLFTRunsPerExperiment() {
		SetupParameters lftSetup = this.parent.getOpenProject().getSetupParameters("lftSetup-");
		if(lftSetup==null)return "N/A";
		Parameter numScenarios = lftSetup.getParameter("numScenarios");
		if(numScenarios==null || numScenarios.getValidationType()==MetaParameter.ValidationType.ERROR)return "N/A";
		Parameter numUncertaintyScenarios = lftSetup.getParameter("numUncertaintyScenarios");
		if(numUncertaintyScenarios==null || numUncertaintyScenarios.getValidationType()==MetaParameter.ValidationType.ERROR)return "N/A";
		Parameter numUncertaintyParams = lftSetup.getParameter("numUncertaintyParams");
		if(numUncertaintyParams==null || numUncertaintyParams.getValidationType()==MetaParameter.ValidationType.ERROR)return "N/A";
		return ((Integer)((Double)(numScenarios.getParameterIntegerValue() * 
				Math.pow(numUncertaintyScenarios.getParameterIntegerValue(), numUncertaintyParams.getParameterIntegerValue()))).intValue()).toString();
	}

}
